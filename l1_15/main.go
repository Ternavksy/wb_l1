/* Проблема в данном коде заключается в том, что при выполнении выражения justString = v[:100]
создаётся подстрока, которая ссылается на тот же участок памяти, что и исходная строка v.
Несмотря на то, что логически в justString хранится только 100 символов, в памяти остаётся весь большой объект v.
Так как justString удерживает ссылку на общий буфер, сборщик мусора не сможет освободить память,
занятую остальной частью строки v.
Это может привести к утечке памяти при работе с очень большими строками

Чтобы избежать этой проблемы, необходимо создать копию нужной части строки, а не использовать общий буфер.
Вот исправленный вариант кода*/

var justString string

func someFunc() {
    v := createHugeString(1 << 10)
    justString = string([]byte(v[:100])) // создаём копию первых 100 символов
}

func main() {
    someFunc()
}

/* В этом случае justString будет хранить независимую копию подстроки,
 и память, занимаемая исходной строкой v, сможет быть освобождена сборщиком мусора